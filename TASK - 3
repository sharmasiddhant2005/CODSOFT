# recommendation_system.py
import pandas as pd
import numpy as np
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.preprocessing import MinMaxScaler

# =============================================================================
# 1. CONTENT-BASED FILTERING SYSTEM
# =============================================================================
class ContentBasedRecommender:
    def __init__(self):
        self.items_df = None
        self.tfidf_matrix = None
        self.feature_names = None
        self.scaler = MinMaxScaler()
    
    def create_sample_data(self):
        """Create sample movie data with genres and features"""
        movies_data = {
            'movie_id': [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
            'title': [
                'The Matrix', 'Inception', 'The Dark Knight', 'Pulp Fiction',
                'Forrest Gump', 'The Shawshank Redemption', 'The Godfather',
                'Fight Club', 'Interstellar', 'The Social Network'
            ],
            'genres': [
                'Action Sci-Fi', 'Action Thriller Sci-Fi', 'Action Crime Drama',
                'Crime Drama', 'Drama Romance', 'Drama', 'Crime Drama',
                'Drama Thriller', 'Adventure Drama Sci-Fi', 'Biography Drama'
            ],
            'keywords': [
                'cyberpunk AI virtual_reality', 'dreams heist subconscious',
                'superhero crime gotham', 'gangster nonlinear dialogue',
                'inspirational historical simple', 'prison hope friendship',
                'mafia family power', 'psychological rebellion anarchy',
                'space time travel', 'technology startup facebook'
            ],
            'rating': [8.7, 8.8, 9.0, 8.9, 8.8, 9.3, 9.2, 8.8, 8.6, 7.7]
        }
        
        self.items_df = pd.DataFrame(movies_data)
        return self.items_df
    
    def prepare_features(self):
        """Prepare features for content-based filtering"""
        # Combine genres and keywords
        self.items_df['content'] = self.items_df['genres'] + ' ' + self.items_df['keywords']
        
        # Create TF-IDF matrix
        tfidf = TfidfVectorizer(stop_words='english', max_features=5000)
        self.tfidf_matrix = tfidf.fit_transform(self.items_df['content'])
        self.feature_names = tfidf.get_feature_names_out()
    
    def get_similar_items(self, item_id, n_recommendations=5):
        """Get similar items based on content"""
        if self.tfidf_matrix is None:
            self.prepare_features()
        
        # Get the index of the item
        idx = self.items_df[self.items_df['movie_id'] == item_id].index[0]
        
        # Calculate cosine similarity
        cosine_sim = cosine_similarity(self.tfidf_matrix[idx], self.tfidf_matrix).flatten()
        
        # Get similar items (excluding the input item itself)
        similar_indices = cosine_sim.argsort()[::-1][1:n_recommendations+1]
        
        recommendations = []
        for i in similar_indices:
            recommendations.append({
                'movie_id': self.items_df.iloc[i]['movie_id'],
                'title': self.items_df.iloc[i]['title'],
                'similarity_score': cosine_sim[i]
            })
        
        return recommendations
    
    def recommend_based_on_preferences(self, liked_genres, n_recommendations=5):
        """Recommend items based on genre preferences"""
        if self.tfidf_matrix is None:
            self.prepare_features()
        
        # Create a TF-IDF vector for the preferred genres
        tfidf = TfidfVectorizer(stop_words='english', max_features=5000)
        tfidf.fit(self.items_df['content'])
        
        user_profile = tfidf.transform([liked_genres])
        
        # Calculate similarity between user profile and all items
        cosine_sim = cosine_similarity(user_profile, self.tfidf_matrix).flatten()
        
        # Get top recommendations
        top_indices = cosine_sim.argsort()[::-1][:n_recommendations]
        
        recommendations = []
        for i in top_indices:
            recommendations.append({
                'movie_id': self.items_df.iloc[i]['movie_id'],
                'title': self.items_df.iloc[i]['title'],
                'genres': self.items_df.iloc[i]['genres'],
                'match_score': cosine_sim[i]
            })
        
        return recommendations

# =============================================================================
# 2. COLLABORATIVE FILTERING SYSTEM
# =============================================================================
class CollaborativeFilteringRecommender:
    def __init__(self):
        self.ratings_df = Nonea
        self.user_item_matrix = None
        self.similarity_matrix = None
    
    def create_sample_ratings(self):
        """Create sample user ratings data"""
        # User ratings data (user_id, movie_id, rating)
        ratings_data = {
            'user_id': [1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4],
            'movie_id': [1, 2, 3, 4, 5, 2, 3, 6, 7, 8, 1, 3, 5, 9, 10, 4, 6, 7, 8, 9],
            'rating': [5, 4, 5, 3, 4, 4, 5, 5, 4, 3, 5, 4, 4, 5, 3, 4, 5, 4, 3, 4]
        }
        
        self.ratings_df = pd.DataFrame(ratings_data)
        return self.ratings_df
    
    def create_user_item_matrix(self):
        """Create user-item rating matrix"""
        self.user_item_matrix = self.ratings_df.pivot_table(
            index='user_id', 
            columns='movie_id', 
            values='rating'
        ).fillna(0)
        return self.user_item_matrix
    
    def calculate_user_similarity(self):
        """Calculate user similarity matrix"""
        if self.user_item_matrix is None:
            self.create_user_item_matrix()
        
        # Calculate cosine similarity between users
        self.similarity_matrix = cosine_similarity(self.user_item_matrix)
        return self.similarity_matrix
    
    def recommend_for_user(self, user_id, n_recommendations=5):
        """Generate recommendations for a user using user-based collaborative filtering"""
        if self.similarity_matrix is None:
            self.calculate_user_similarity()
        
        # Get the target user's index
        user_idx = list(self.user_item_matrix.index).index(user_id)
        
        # Get similar users
        user_similarities = self.similarity_matrix[user_idx]
        
        # Get items the user hasn't rated yet
        user_ratings = self.user_item_matrix.iloc[user_idx]
        unrated_items = user_ratings[user_ratings == 0].index
        
        # Calculate predicted ratings for unrated items
        predictions = {}
        
        for item in unrated_items:
            weighted_sum = 0
            similarity_sum = 0
            
            for other_user_idx, similarity in enumerate(user_similarities):
                if similarity > 0 and other_user_idx != user_idx:
                    other_user_rating = self.user_item_matrix.iloc[other_user_idx][item]
                    if other_user_rating > 0:
                        weighted_sum += similarity * other_user_rating
                        similarity_sum += similarity
            
            if similarity_sum > 0:
                predicted_rating = weighted_sum / similarity_sum
                predictions[item] = predicted_rating
        
        # Get top recommendations
        recommendations = sorted(predictions.items(), key=lambda x: x[1], reverse=True)[:n_recommendations]
        
        return recommendations

